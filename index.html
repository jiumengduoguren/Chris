<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bright Christmas Magic | Gesture Controlled</title>
    <style>
        /* ä¿®æ”¹ç‰ˆèƒŒæ™¯ï¼šæ›´æœ‰æ°›å›´çš„åœ£è¯å¢¨ç»¿æ¸å˜ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #1a2e1a 0%, #000000 100%);
            font-family: 'Helvetica Neue', sans-serif; 
        }
        canvas { display: block; }
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); border-radius: 8px; opacity: 0.7; z-index: 10; border: 2px solid #D4AF37; display: none;}
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .controls { pointer-events: auto; position: absolute; top: 20px; left: 20px; color: #D4AF37; }
        button { background: rgba(20, 20, 20, 0.8); color: #D4AF37; border: 1px solid #D4AF37; padding: 10px 20px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s; }
        button:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        #status { position: absolute; bottom: 20px; right: 20px; color: rgba(255,255,255,0.8); font-size: 14px; text-align: right; }
        .state-indicator { font-size: 24px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #D4AF37; margin-bottom: 5px; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; font-size: 20px; animation: pulse 1.5s infinite; pointer-events: none;}
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <video id="video-input" playsinline></video>
    
    <div id="ui-layer">
        <div class="controls">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
            <div style="margin-top: 10px; font-size: 14px; font-weight: bold; opacity: 1; color: #FFD700;">
                <p>âœŠ æ¡æ‹³: å˜å›åœ£è¯æ ‘</p>
                <p>ğŸ– å¼ å¼€: å˜æˆæ»¡å¤©æ˜Ÿ (ç§»åŠ¨æ‰‹æŒæ—‹è½¬)</p>
                <p>ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡ (å±…ä¸­æ”¾å¤§)</p>
            </div>
        </div>
        <div id="status">
            <div class="state-indicator" id="current-state">INITIALIZING...</div>
            <div id="hand-status">ç­‰å¾…æ‘„åƒå¤´æˆæƒ...</div>
        </div>
        <div id="loader">æ­£åœ¨åŠ è½½åœ£è¯é­”æ³•...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® (é«˜äº®ç‰ˆ) ---
        const CONFIG = {
            colors: {
                green: 0x006400,
                gold: 0xFFD700,
                red: 0xFF0000,
                white: 0xFFFFFF
            },
            particleCount: 1000,
            treeHeight: 25,
            treeRadius: 10,
            bloomThreshold: 0.1,
            bloomStrength: 2.0,
            bloomRadius: 0.5
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const APP_STATE = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            targetRotation: { x: 0, y: 0 },
            isHandDetected: false,
            gesture: 'NONE'
        };

        // --- Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a2e1a, 0.01);
        
        // ç›¸æœºä½ç½®å›ºå®šåœ¨ Z=40
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;
        document.body.appendChild(renderer.domElement);

        // --- åå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç¯å…‰ (æ˜äº®æš–è‰²è°ƒ) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffaa33, 2.0);
        mainLight.position.set(10, 20, 20);
        scene.add(mainLight);
        const backLight = new THREE.DirectionalLight(0xcceeff, 1.0);
        backLight.position.set(-10, 10, -20);
        scene.add(backLight);
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 3, 100);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // --- ç²’å­ç³»ç»Ÿæ„å»º ---
        const dummy = new THREE.Object3D();
        let particlesMesh;
        let particlesData = []; 

        function createParticles() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff, roughness: 0.2, metalness: 0.8, emissive: 0x000000
            });

            particlesMesh = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); 

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const colorType = Math.random();
                const color = new THREE.Color();
                if (colorType < 0.5) color.setHex(CONFIG.colors.green);
                else if (colorType < 0.8) color.setHex(CONFIG.colors.gold);
                else color.setHex(CONFIG.colors.red);
                particlesMesh.setColorAt(i, color);

                particlesData.push({
                    id: i,
                    currentPos: new THREE.Vector3(),
                    treePos: getTreePosition(i, CONFIG.particleCount),
                    scatterPos: getScatterPosition(),
                    scale: Math.random() * 0.5 + 0.5,
                    phase: Math.random() * Math.PI * 2
                });
                dummy.position.copy(particlesData[i].treePos);
                particlesData[i].currentPos.copy(particlesData[i].treePos);
                dummy.scale.setScalar(particlesData[i].scale);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            scene.add(particlesMesh);
        }

        // --- åæ ‡ç®—æ³• ---
        function getTreePosition(index, total) {
            const y = (1 - (index / total)) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
            const radius = (CONFIG.treeHeight / 2 - y) * 0.4; 
            const angle = index * 0.5; 
            return new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
        }

        function getScatterPosition() {
            const u = Math.random(); const v = Math.random();
            const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
            const r = 15 + Math.random() * 20; 
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        createParticles();

        // --- ç…§ç‰‡äº‘ç®¡ç† (å«è‡ªåŠ¨åŠ è½½) ---
        const photosGroup = new THREE.Group();
        scene.add(photosGroup);
        const photoMeshes = [];
        const textureLoader = new THREE.TextureLoader();
        // è¯·ç¡®ä¿GitHubä»“åº“é‡Œæœ‰è¿™äº›æ–‡ä»¶
        const myPhotoFiles = ['1.jpg', '2.jpg', '3.jpg']; 

        myPhotoFiles.forEach((fileName, index) => {
            textureLoader.load(fileName, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const img = texture.image;
                const aspect = img.width / img.height;
                const geometry = new THREE.PlaneGeometry(3 * aspect, 3);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, toneMapped: false });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = {
                    treePos: new THREE.Vector3(Math.sin(index * 2) * 6, (Math.random() - 0.5) * 15, Math.cos(index * 2) * 6 + 5),
                    scatterPos: new THREE.Vector3((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 10),
                    originalScale: 1
                };
                mesh.position.copy(mesh.userData.treePos);
                mesh.lookAt(0, 0, 0);
                const borderGeo = new THREE.EdgesGeometry(geometry);
                const borderMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.gold });
                mesh.add(new THREE.LineSegments(borderGeo, borderMat));
                photosGroup.add(mesh);
                photoMeshes.push(mesh);
            }, undefined, (err) => console.error('åŠ è½½ç…§ç‰‡å¤±è´¥:', fileName));
        });

        // --- æ ¸å¿ƒåŠ¨ç”»é€»è¾‘ (GSAP) ---
        function switchState(newState) {
            if (APP_STATE.mode === newState) return;
            APP_STATE.mode = newState;
            document.getElementById('current-state').innerText = newState;

            // ç²’å­åŠ¨ç”»
            particlesData.forEach(p => {
                const target = newState === 'TREE' ? p.treePos : p.scatterPos;
                gsap.to(p.currentPos, {
                    x: target.x, y: target.y, z: target.z,
                    duration: 1.5 + Math.random(), ease: "power3.inOut",
                    onUpdate: () => { p.needsUpdate = true; }
                });
            });

            // ç…§ç‰‡åŠ¨ç”»ï¼šå¦‚æœæ˜¯å»ZOOMæ¨¡å¼ï¼Œå…ˆä¸ç»Ÿä¸€ç§»åŠ¨ç…§ç‰‡
            photoMeshes.forEach(mesh => {
                if (newState === 'ZOOM') return; 
                const target = newState === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos;
                gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                gsap.to(mesh.position, {
                    x: target.x, y: target.y, z: target.z, duration: 1.5, ease: "power2.inOut",
                    onUpdate: () => mesh.lookAt(0,0,0)
                });
                 // å¦‚æœä» ZOOM æ¨¡å¼å›æ¥ï¼Œéœ€è¦é‡ç½®æ—‹è½¬è®©å®ƒå†æ¬¡çœ‹å‘ä¸­å¿ƒ
                 if (APP_STATE.mode !== 'ZOOM') {
                     gsap.to({}, {duration: 1.5, onUpdate: () => mesh.lookAt(0,0,0)});
                 }
            });

            if (newState === 'ZOOM') zoomRandomPhoto();
        }

        // --- ã€å…³é”®ä¿®æ”¹ã€‘æŠ“å–ç…§ç‰‡å±…ä¸­é€»è¾‘ ---
        function zoomRandomPhoto() {
            if (photoMeshes.length === 0) return;
            const targetPhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
            
            // 1. è®¾å®šç»å¯¹ä¸­å¿ƒä½ç½® (ç›¸æœºåœ¨Z=40, ç…§ç‰‡æ”¾åœ¨Z=25, X=0, Y=0)
            const targetPos = new THREE.Vector3(0, 0, 25);

            // 2. ä½ç½®åŠ¨ç”»ï¼šä½¿ç”¨æ›´å¹³æ»‘çš„ power3.out ç¼“åŠ¨
            gsap.to(targetPhoto.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                duration: 1.2, ease: "power3.out"
            });
            
            // 3. ç¼©æ”¾åŠ¨ç”»ï¼šç¨å¾®æ”¾å¤§ä¸€ç‚¹
            gsap.to(targetPhoto.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 1.2, ease: "power3.out" });
            
            // 4. ã€é‡è¦ã€‘å¼ºåˆ¶ç…§ç‰‡æ—‹è½¬å½’é›¶ï¼Œæ­£å¯¹å±å¹•
            gsap.to(targetPhoto.rotation, { 
                x: 0, y: 0, z: 0, 
                duration: 1.2, ease: "power3.out" 
            });
        }

        // --- MediaPipe Hands ---
        const videoElement = document.getElementById('video-input');
        const handStatus = document.getElementById('hand-status');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                APP_STATE.isHandDetected = true;
                analyzeGesture(results.multiHandLandmarks[0]);
            } else {
                APP_STATE.isHandDetected = false;
                handStatus.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
        }

        function analyzeGesture(landmarks) {
            const isFingerExtended = (tipId, pipId) => {
                const dTip = Math.hypot(landmarks[tipId].x - landmarks[0].x, landmarks[tipId].y - landmarks[0].y);
                const dPip = Math.hypot(landmarks[pipId].x - landmarks[0].x, landmarks[pipId].y - landmarks[0].y);
                return dTip > dPip * 1.2;
            };
            const openFingers = [4,8,12,16,20].map(tip => isFingerExtended(tip, tip-2)).filter(Boolean).length;

            if (openFingers <= 1) {
                handStatus.innerText = "è¯†åˆ«: âœŠ æ¡æ‹³ (èšåˆ)";
                switchState('TREE');
            }
            else if (openFingers >= 4) {
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                if (pinchDist < 0.05) {
                    handStatus.innerText = "è¯†åˆ«: ğŸ‘Œ æåˆ (å±…ä¸­æ”¾å¤§)";
                    // æåˆæ—¶ç›´æ¥åˆ‡æ¢åˆ° ZOOM
                    if (APP_STATE.mode !== 'ZOOM') switchState('ZOOM');
                } else {
                    handStatus.innerText = "è¯†åˆ«: ğŸ– å¼ å¼€ (æ•£å¼€æ—‹è½¬)";
                    if (APP_STATE.mode !== 'SCATTER') switchState('SCATTER');
                    // åªæœ‰åœ¨ SCATTER æ¨¡å¼ä¸‹æ‰è®¡ç®—æ‰‹åŠ¿æ—‹è½¬ç›®æ ‡
                    APP_STATE.targetRotation.x = (landmarks[0].y - 0.5) * 2 * 0.5;
                    APP_STATE.targetRotation.y = (landmarks[0].x - 0.5) * 2 * 0.5;
                }
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => await hands.send({image: videoElement}), width: 320, height: 240 });
        cameraUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // ç²’å­æ›´æ–°
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const data = particlesData[i];
                dummy.position.set(data.currentPos.x, data.currentPos.y + Math.sin(time + data.phase) * 0.1, data.currentPos.z);
                dummy.scale.setScalar(data.scale); dummy.lookAt(camera.position); 
                dummy.updateMatrix(); particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // ã€å…³é”®ä¿®æ”¹ã€‘åœºæ™¯æ—‹è½¬é€»è¾‘åŒºåˆ†
            if (APP_STATE.mode === 'SCATTER') {
                // æ•£å¼€æ¨¡å¼ï¼šè·Ÿéšæ‰‹åŠ¿æ—‹è½¬
                scene.rotation.x += (APP_STATE.targetRotation.x - scene.rotation.x) * 0.05;
                scene.rotation.y += (APP_STATE.targetRotation.y - scene.rotation.y) * 0.05;
            } else if (APP_STATE.mode === 'ZOOM') {
                // æ”¾å¤§æ¨¡å¼ï¼šå¼ºåˆ¶åœºæ™¯æ…¢æ…¢å›æ­£åˆ°ä¸­å¿ƒ (0,0,0)
                scene.rotation.x += (0 - scene.rotation.x) * 0.1;
                scene.rotation.y += (0 - scene.rotation.y) * 0.1;
            } else {
                // åœ£è¯æ ‘æ¨¡å¼ï¼šè‡ªåŠ¨æ…¢æ—‹è½¬
                scene.rotation.y += 0.002;
                scene.rotation.x += (0 - scene.rotation.x) * 0.05;
            }

            // ç…§ç‰‡æ¼‚æµ®
            photosGroup.children.forEach((mesh, i) => {
                // åœ¨ ZOOM æ¨¡å¼ä¸‹æš‚åœæ¼‚æµ®åŠ¨ç”»ï¼Œé¿å…æŠ–åŠ¨
                if (APP_STATE.mode !== 'ZOOM') mesh.position.y += Math.sin(time * 2 + i) * 0.01;
            });

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
