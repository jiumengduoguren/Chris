<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree | 3D Particles & MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        canvas { display: block; }
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); border-radius: 8px; opacity: 0.7; z-index: 10; border: 2px solid #D4AF37; display: none;}
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .controls { pointer-events: auto; position: absolute; top: 20px; left: 20px; color: #D4AF37; }
        button { background: rgba(20, 20, 20, 0.8); color: #D4AF37; border: 1px solid #D4AF37; padding: 10px 20px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s; }
        button:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        #status { position: absolute; bottom: 20px; right: 20px; color: rgba(255,255,255,0.6); font-size: 14px; text-align: right; }
        .state-indicator { font-size: 24px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #D4AF37; margin-bottom: 5px; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; font-size: 20px; animation: pulse 1.5s infinite; pointer-events: none;}
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <video id="video-input" playsinline></video>
    
    <div id="ui-layer">
        <div class="controls">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
            <button onclick="document.getElementById('photo-upload').click()">+ ä¸Šä¼ ç…§ç‰‡ (æ‰“é€ ç…§ç‰‡äº‘)</button>
            <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
                <p>âœŠ æ¡æ‹³: èšåˆ (åœ£è¯æ ‘)</p>
                <p>ğŸ– å¼ å¼€: æ•£å¼€ (æ˜Ÿäº‘)</p>
                <p>ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡ (æ”¾å¤§)</p>
            </div>
        </div>
        <div id="status">
            <div class="state-indicator" id="current-state">INITIALIZING...</div>
            <div id="hand-status">ç­‰å¾…æ‘„åƒå¤´...</div>
        </div>
        <div id="loader">åŠ è½½æ¨¡å‹ä¸è§†è§‰ç®—æ³•ä¸­...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            colors: {
                green: 0x2F4F4F, // å“‘å…‰ç»¿
                gold: 0xFFD700,  // é‡‘å±é‡‘
                red: 0x8B0000,   // åœ£è¯çº¢
                white: 0xFFFFFF
            },
            particleCount: 800,
            treeHeight: 25,
            treeRadius: 10,
            bloomThreshold: 0,
            bloomStrength: 1.5,
            bloomRadius: 0.8
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const APP_STATE = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            targetRotation: { x: 0, y: 0 },
            isHandDetected: false,
            gesture: 'NONE'
        };

        // --- Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- åå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç¯å…‰ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
        
        // è¡¥å…‰ï¼Œå¢åŠ é‡‘å±è´¨æ„Ÿ
        const blueLight = new THREE.PointLight(0x0000ff, 1, 100);
        blueLight.position.set(-20, -10, 0);
        scene.add(blueLight);

        // --- ç²’å­ç³»ç»Ÿæ„å»º (InstancedMesh) ---
        const dummy = new THREE.Object3D();
        let particlesMesh;
        let particlesData = []; // å­˜å‚¨æ¯ä¸ªç²’å­çš„æºä½ç½®ã€ç›®æ ‡ä½ç½®ã€é¢œè‰²ç­‰

        function createParticles() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.9,
                emissive: 0x000000
            });

            particlesMesh = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // æ ‡è®°ä¸ºåŠ¨æ€æ›´æ–°

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // åˆå§‹åŒ–éšæœºé¢œè‰²
                const colorType = Math.random();
                const color = new THREE.Color();
                if (colorType < 0.6) color.setHex(CONFIG.colors.green);
                else if (colorType < 0.85) color.setHex(CONFIG.colors.gold);
                else color.setHex(CONFIG.colors.red);
                
                particlesMesh.setColorAt(i, color);

                // æ•°æ®ç»“æ„
                particlesData.push({
                    id: i,
                    currentPos: new THREE.Vector3(),
                    treePos: getTreePosition(i, CONFIG.particleCount),
                    scatterPos: getScatterPosition(),
                    scale: Math.random() * 0.5 + 0.5,
                    phase: Math.random() * Math.PI * 2
                });
                
                // åˆå§‹è®¾ä¸ºæ ‘çš„çŠ¶æ€
                dummy.position.copy(particlesData[i].treePos);
                particlesData[i].currentPos.copy(particlesData[i].treePos);
                dummy.scale.setScalar(particlesData[i].scale);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            
            scene.add(particlesMesh);
        }

        // --- åæ ‡ç®—æ³• ---
        
        // 1. åœ£è¯æ ‘ (èºæ—‹åœ†é”¥)
        function getTreePosition(index, total) {
            const y = (1 - (index / total)) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
            const radius = (CONFIG.treeHeight / 2 - y) * 0.4; // ä¸Šçª„ä¸‹å®½
            const angle = index * 0.5; // èºæ—‹å¯†åº¦
            
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            return new THREE.Vector3(x, y, z);
        }

        // 2. æ•£å¼€ (çƒå½¢æ˜Ÿäº‘)
        function getScatterPosition() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 15 + Math.random() * 20; // æ•£å¼€åŠå¾„
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        createParticles();

        // --- ç…§ç‰‡äº‘ç®¡ç† ---
        const photosGroup = new THREE.Group();
        scene.add(photosGroup);
        const photoMeshes = [];

        document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);

        function handlePhotoUpload(e) {
            const files = e.target.files;
            if (!files.length) return;

            // æ¸…ç†æ—§ç…§ç‰‡
            photoMeshes.forEach(mesh => photosGroup.remove(mesh));
            photoMeshes.length = 0;

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace;

                        const aspect = img.width / img.height;
                        const geometry = new THREE.PlaneGeometry(3 * aspect, 3);
                        // é‡‘è¾¹ç…§ç‰‡æ¡†
                        const material = new THREE.MeshBasicMaterial({ 
                            map: texture, 
                            side: THREE.DoubleSide 
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        // ä¸ºæ¯å¼ ç…§ç‰‡åˆ†é… Tree å’Œ Scatter åæ ‡
                        mesh.userData = {
                            treePos: new THREE.Vector3(
                                Math.sin(index * 2) * 6,
                                (Math.random() - 0.5) * 15,
                                Math.cos(index * 2) * 6 + 5 // ç¨å¾®å‘å¤–
                            ),
                            scatterPos: new THREE.Vector3(
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 10
                            ),
                            originalScale: 1
                        };

                        mesh.position.copy(mesh.userData.treePos);
                        mesh.lookAt(0,0,0);
                        
                        // æ·»åŠ é‡‘è¾¹æ¡†
                        const borderGeo = new THREE.EdgesGeometry(geometry);
                        const borderMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.gold });
                        const border = new THREE.LineSegments(borderGeo, borderMat);
                        mesh.add(border);

                        photosGroup.add(mesh);
                        photoMeshes.push(mesh);
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        // --- æ ¸å¿ƒåŠ¨ç”»é€»è¾‘ (GSAP) ---
        function switchState(newState) {
            if (APP_STATE.mode === newState) return;
            APP_STATE.mode = newState;
            
            const stateText = document.getElementById('current-state');
            stateText.innerText = newState;

            // 1. ç²’å­åŠ¨ç”»
            particlesData.forEach(p => {
                const target = newState === 'TREE' ? p.treePos : p.scatterPos;
                
                // ä¸ºæ¯ä¸ªç²’å­åˆ›å»ºç¨å¾®ä¸åŒçš„å»¶è¿Ÿï¼Œå½¢æˆæµä½“æ„Ÿ
                gsap.to(p.currentPos, {
                    x: target.x,
                    y: target.y,
                    z: target.z,
                    duration: 1.5 + Math.random(),
                    ease: "power3.inOut",
                    onUpdate: () => {
                        // æ ‡è®°åœ¨ render loop ä¸­æ›´æ–° mesh
                        p.needsUpdate = true;
                    }
                });
            });

            // 2. ç…§ç‰‡åŠ¨ç”»
            photoMeshes.forEach(mesh => {
                const target = newState === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos;
                
                // æ¢å¤ç¼©æ”¾
                gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                
                gsap.to(mesh.position, {
                    x: target.x,
                    y: target.y,
                    z: target.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => mesh.lookAt(0,0,0) // å§‹ç»ˆæœå‘ä¸­å¿ƒ
                });
            });

            // 3. çŠ¶æ€ç‰¹å®šé€»è¾‘
            if (newState === 'ZOOM') {
               zoomRandomPhoto();
            }
        }

        function zoomRandomPhoto() {
            if (photoMeshes.length === 0) return;
            // æ‰¾åˆ°ç¦»ç›¸æœºæœ€è¿‘æˆ–è€…éšæœºä¸€å¼ 
            const targetPhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
            
            // å°†å…¶ç§»åŠ¨åˆ°ç›¸æœºå‰æ–¹
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const targetPos = camera.position.clone().add(camDir.multiplyScalar(10));

            gsap.to(targetPhoto.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 1,
                ease: "back.out(1.7)"
            });

            gsap.to(targetPhoto.scale, {
                x: 2, y: 2, z: 2,
                duration: 1
            });
            
            // è®©å®ƒæœå‘ç›¸æœº
            gsap.to({}, { duration: 1, onUpdate: () => targetPhoto.lookAt(camera.position) });
        }

        // --- MediaPipe Hands é›†æˆ ---
        const videoElement = document.getElementById('video-input');
        const canvasElement = document.createElement('canvas'); // å†…éƒ¨ç”¨äºåˆ†æçš„canvas
        const canvasCtx = canvasElement.getContext('2d');
        const handStatus = document.getElementById('hand-status');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('video-input').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                APP_STATE.isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                analyzeGesture(landmarks);
            } else {
                APP_STATE.isHandDetected = false;
                handStatus.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
        }

        function analyzeGesture(landmarks) {
            // ç®€å•çš„æ‰‹æŒ‡åˆ¤æ–­ï¼šæŒ‡å°–(Tip) yåæ ‡ æ˜¯å¦å°äº æŒ‡å…³èŠ‚(PIP) yåæ ‡ (æ³¨æ„ Canvas åæ ‡ç³» y å‘ä¸‹ä¸ºæ­£)
            // è¿™é‡Œç”¨å‘é‡è·ç¦»æˆ–ç›¸å¯¹ä½ç½®æ›´å‡†ï¼Œä¸ºäº†å•æ–‡ä»¶ç®€æ´ï¼Œæˆ‘ä»¬åˆ¤æ–­æŒ‡å°–æ˜¯å¦ä¼¸å±•
            
            const isFingerExtended = (tipId, pipId) => {
                // å¦‚æœæŒ‡å°–å’Œæ‰‹è…•çš„è·ç¦» > æŒ‡å…³èŠ‚å’Œæ‰‹è…•çš„è·ç¦»ï¼Œå¤§æ¦‚ç‡æ˜¯ä¼¸ç›´
                const wrist = landmarks[0];
                const tip = landmarks[tipId];
                const pip = landmarks[pipId];
                
                const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                return dTip > dPip * 1.2; // 1.2 æ˜¯é˜ˆå€¼
            };

            const thumbOpen = isFingerExtended(4, 2);
            const indexOpen = isFingerExtended(8, 6);
            const middleOpen = isFingerExtended(12, 10);
            const ringOpen = isFingerExtended(16, 14);
            const pinkyOpen = isFingerExtended(20, 18);

            const openFingersCount = [thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;

            // 1. æ¡æ‹³ (FIST) -> TREE
            if (openFingersCount <= 1) {
                handStatus.innerText = "è¯†åˆ«: æ¡æ‹³ (èšåˆ)";
                switchState('TREE');
            }
            // 2. äº”æŒ‡å¼ å¼€ (OPEN) -> SCATTER
            else if (openFingersCount >= 4) {
                // æ£€æŸ¥æ˜¯å¦åœ¨æåˆ (PINCH) -> ZOOM
                // æ‹‡æŒ‡(4) å’Œ é£ŸæŒ‡(8) çš„è·ç¦»
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                
                if (pinchDist < 0.05) {
                    handStatus.innerText = "è¯†åˆ«: æåˆ (æŸ¥çœ‹ç…§ç‰‡)";
                    switchState('ZOOM');
                } else {
                    handStatus.innerText = "è¯†åˆ«: å¼ å¼€ (æ•£å¼€æ§åˆ¶)";
                    if (APP_STATE.mode !== 'SCATTER') switchState('SCATTER');
                    
                    // 3. æ—‹è½¬é€»è¾‘ (åœ¨ Scatter æ¨¡å¼ä¸‹)
                    // ä½¿ç”¨æ‰‹è…•åæ ‡ (landmarks[0]) æ§åˆ¶æ—‹è½¬
                    // x: 0-1, y: 0-1. ä¸­å¿ƒ 0.5
                    const handX = (landmarks[0].x - 0.5) * 2; // -1 to 1
                    const handY = (landmarks[0].y - 0.5) * 2;
                    
                    // å¹³æ»‘é˜»å°¼ç›®æ ‡å€¼
                    APP_STATE.targetRotation.x = handY * 0.5;
                    APP_STATE.targetRotation.y = handX * 0.5;
                }
            } else {
                handStatus.innerText = "è¯†åˆ«: ...";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        cameraUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // 1. æ›´æ–°ç²’å­çŸ©é˜µ
            // ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ¯å¸§éƒ½é‡ç®—æ‰€æœ‰çŸ©é˜µï¼Œåªæœ‰åœ¨åŠ¨ç”»æ—¶æˆ–éœ€è¦å¾®åŠ¨æ—¶æ›´æ–°
            // è¿™é‡ŒåŠ å…¥è½»å¾®çš„æ¼‚æµ®åŠ¨ç”»
            let needsUpdate = false;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const data = particlesData[i];
                
                // è·å–åŠ¨ç”»æ’å€¼åçš„ä½ç½®
                const x = data.currentPos.x;
                const y = data.currentPos.y + Math.sin(time + data.phase) * 0.1; // å‘¼å¸æ•ˆæœ
                const z = data.currentPos.z;

                dummy.position.set(x, y, z);
                dummy.scale.setScalar(data.scale);
                dummy.lookAt(camera.position); // å¦‚æœæ˜¯æ™®é€šçƒä½“ä¸éœ€è¦ï¼Œä½†å¦‚æœæ˜¯å¸¦çº¹ç†çš„å°±éœ€è¦
                dummy.updateMatrix();
                
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // 2. åœºæ™¯æ•´ä½“æ—‹è½¬ (åŸºäºæ‰‹åŠ¿)
            if (APP_STATE.mode === 'SCATTER' || APP_STATE.mode === 'ZOOM') {
                // å¹³æ»‘æ’å€¼æ—‹è½¬
                scene.rotation.x += (APP_STATE.targetRotation.x - scene.rotation.x) * 0.05;
                scene.rotation.y += (APP_STATE.targetRotation.y - scene.rotation.y) * 0.05;
            } else {
                // Tree æ¨¡å¼ä¸‹è‡ªåŠ¨ç¼“æ…¢æ—‹è½¬
                scene.rotation.y += 0.002;
                // å½’ä½ X è½´
                scene.rotation.x += (0 - scene.rotation.x) * 0.05;
            }

            // 3. ç…§ç‰‡æ¼‚æµ®
            photosGroup.children.forEach((mesh, i) => {
                 mesh.position.y += Math.sin(time * 2 + i) * 0.01;
            });

            // renderer.render(scene, camera); // æ™®é€šæ¸²æŸ“
            composer.render(); // åå¤„ç†æ¸²æŸ“
        }

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>