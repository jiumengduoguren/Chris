<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bright Christmas Magic | Gesture Controlled</title>
    <style>
        /* ä¿®æ”¹ç‰ˆèƒŒæ™¯ï¼šæ›´æœ‰æ°›å›´çš„åœ£è¯å¢¨ç»¿æ¸å˜ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #1a2e1a 0%, #000000 100%);
            font-family: 'Helvetica Neue', sans-serif; 
        }
        canvas { display: block; }
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); border-radius: 8px; opacity: 0.7; z-index: 10; border: 2px solid #D4AF37; display: none;}
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .controls { pointer-events: auto; position: absolute; top: 20px; left: 20px; color: #D4AF37; }
        button { background: rgba(20, 20, 20, 0.8); color: #D4AF37; border: 1px solid #D4AF37; padding: 10px 20px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s; }
        button:hover { background: #D4AF37; color: #000; box-shadow: 0 0 15px #D4AF37; }
        #status { position: absolute; bottom: 20px; right: 20px; color: rgba(255,255,255,0.8); font-size: 14px; text-align: right; }
        .state-indicator { font-size: 24px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #D4AF37; margin-bottom: 5px; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; font-size: 20px; animation: pulse 1.5s infinite; pointer-events: none;}
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <video id="video-input" playsinline></video>
    
    <div id="ui-layer">
        <div class="controls">
            <input type="file" id="photo-upload" multiple accept="image/*" style="display: none;">
            <div style="margin-top: 10px; font-size: 14px; font-weight: bold; opacity: 1; color: #FFD700;">
                <p>âœŠ æ¡æ‹³: å˜å›åœ£è¯æ ‘</p>
                <p>ğŸ– å¼ å¼€: å˜æˆæ»¡å¤©æ˜Ÿ</p>
                <p>ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡æ”¾å¤§</p>
            </div>
        </div>
        <div id="status">
            <div class="state-indicator" id="current-state">INITIALIZING...</div>
            <div id="hand-status">ç­‰å¾…æ‘„åƒå¤´æˆæƒ...</div>
        </div>
        <div id="loader">æ­£åœ¨åŠ è½½åœ£è¯é­”æ³•...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® (ä¿®æ”¹ç‰ˆï¼šé«˜äº®) ---
        const CONFIG = {
            colors: {
                green: 0x006400, // æ›´é²œè‰³çš„æ·±ç»¿
                gold: 0xFFD700,  // æ˜äº®çš„é‡‘
                red: 0xFF0000,   // æ­£çº¢
                white: 0xFFFFFF
            },
            particleCount: 1000, // ç¨å¾®å¢åŠ ç²’å­
            treeHeight: 25,
            treeRadius: 10,
            bloomThreshold: 0.1, // é™ä½é˜ˆå€¼ï¼Œè®©æ›´å¤šä¸œè¥¿å‘å…‰
            bloomStrength: 2.0,  // åŠ å¼ºè¾‰å…‰
            bloomRadius: 0.5
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const APP_STATE = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            targetRotation: { x: 0, y: 0 },
            isHandDetected: false,
            gesture: 'NONE'
        };

        // --- Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        // é™ä½é›¾çš„æµ“åº¦ï¼Œè®©è¿œå¤„çš„ç¯å…‰ä¹Ÿèƒ½é€è¿‡æ¥
        scene.fog = new THREE.FogExp2(0x1a2e1a, 0.01);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5; // æé«˜æ•´ä½“æ›å…‰åº¦
        document.body.appendChild(renderer.domElement);

        // --- åå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç¯å…‰ (ä¿®æ”¹ç‰ˆï¼šæ˜äº®æš–è‰²è°ƒ) ---
        // 1. ç¯å¢ƒå…‰ï¼šå°±åƒæŠŠæˆ¿é—´çš„å¤§ç¯æ‰“å¼€
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);

        // 2. ä¸»å…‰æºï¼šæš–é»„è‰²çš„å¼ºå…‰
        const mainLight = new THREE.DirectionalLight(0xffaa33, 2.0);
        mainLight.position.set(10, 20, 20);
        scene.add(mainLight);

        // 3. è¡¥å…‰ï¼šèƒŒåçš„å†·å…‰
        const backLight = new THREE.DirectionalLight(0xcceeff, 1.0);
        backLight.position.set(-10, 10, -20);
        scene.add(backLight);

        // 4. ç‚¹å…‰æºï¼šåŸæœ¬çš„é‡‘è‰²å…‰ç‚¹
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 3, 100);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // --- ç²’å­ç³»ç»Ÿæ„å»º (InstancedMesh) ---
        const dummy = new THREE.Object3D();
        let particlesMesh;
        let particlesData = []; 

        function createParticles() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.2, // è¡¨é¢æ›´å…‰æ»‘
                metalness: 0.8, // é‡‘å±æ„Ÿæ›´å¼º
                emissive: 0x000000
            });

            particlesMesh = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); 

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const colorType = Math.random();
                const color = new THREE.Color();
                // è°ƒæ•´é¢œè‰²åˆ†å¸ƒï¼Œè®©é‡‘è‰²å’Œçº¢è‰²æ›´å¤š
                if (colorType < 0.5) color.setHex(CONFIG.colors.green);
                else if (colorType < 0.8) color.setHex(CONFIG.colors.gold);
                else color.setHex(CONFIG.colors.red);
                
                particlesMesh.setColorAt(i, color);

                particlesData.push({
                    id: i,
                    currentPos: new THREE.Vector3(),
                    treePos: getTreePosition(i, CONFIG.particleCount),
                    scatterPos: getScatterPosition(),
                    scale: Math.random() * 0.5 + 0.5,
                    phase: Math.random() * Math.PI * 2
                });
                
                dummy.position.copy(particlesData[i].treePos);
                particlesData[i].currentPos.copy(particlesData[i].treePos);
                dummy.scale.setScalar(particlesData[i].scale);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            
            scene.add(particlesMesh);
        }

        // --- åæ ‡ç®—æ³• ---
        function getTreePosition(index, total) {
            const y = (1 - (index / total)) * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
            const radius = (CONFIG.treeHeight / 2 - y) * 0.4; 
            const angle = index * 0.5; 
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            return new THREE.Vector3(x, y, z);
        }

        function getScatterPosition() {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 15 + Math.random() * 20; 
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        createParticles();

        // --- ç…§ç‰‡äº‘ç®¡ç† (å«è‡ªåŠ¨åŠ è½½) ---
        const photosGroup = new THREE.Group();
        scene.add(photosGroup);
        const photoMeshes = [];

        // è‡ªåŠ¨åŠ è½½ç…§ç‰‡é€»è¾‘
        const textureLoader = new THREE.TextureLoader();
        // è¿™é‡Œå®šä¹‰ä½ è¦åŠ è½½çš„æ–‡ä»¶å
        const myPhotoFiles = ['1.jpg', '2.jpg', '3.jpg']; 

        myPhotoFiles.forEach((fileName, index) => {
            textureLoader.load(fileName, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                const img = texture.image;
                const aspect = img.width / img.height;
                const geometry = new THREE.PlaneGeometry(3 * aspect, 3);
                // æé«˜ç…§ç‰‡äº®åº¦
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide,
                    toneMapped: false // ç¡®ä¿ç…§ç‰‡ä¸å—æ›å…‰å½±å“å˜æš—
                });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.userData = {
                    treePos: new THREE.Vector3(
                        Math.sin(index * 2) * 6,
                        (Math.random() - 0.5) * 15,
                        Math.cos(index * 2) * 6 + 5
                    ),
                    scatterPos: new THREE.Vector3(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 10
                    ),
                    originalScale: 1
                };

                mesh.position.copy(mesh.userData.treePos);
                mesh.lookAt(0, 0, 0);

                const borderGeo = new THREE.EdgesGeometry(geometry);
                const borderMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.gold });
                const border = new THREE.LineSegments(borderGeo, borderMat);
                mesh.add(border);

                photosGroup.add(mesh);
                photoMeshes.push(mesh);
            }, undefined, (err) => {
                console.error('åŠ è½½ç…§ç‰‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦æ­£ç¡®:', fileName);
            });
        });

        // --- æ ¸å¿ƒåŠ¨ç”»é€»è¾‘ (GSAP) ---
        function switchState(newState) {
            if (APP_STATE.mode === newState) return;
            APP_STATE.mode = newState;
            
            const stateText = document.getElementById('current-state');
            stateText.innerText = newState;

            particlesData.forEach(p => {
                const target = newState === 'TREE' ? p.treePos : p.scatterPos;
                gsap.to(p.currentPos, {
                    x: target.x, y: target.y, z: target.z,
                    duration: 1.5 + Math.random(),
                    ease: "power3.inOut",
                    onUpdate: () => { p.needsUpdate = true; }
                });
            });

            photoMeshes.forEach(mesh => {
                const target = newState === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos;
                gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                gsap.to(mesh.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => mesh.lookAt(0,0,0)
                });
            });

            if (newState === 'ZOOM') zoomRandomPhoto();
        }

        function zoomRandomPhoto() {
            if (photoMeshes.length === 0) return;
            const targetPhoto = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const targetPos = camera.position.clone().add(camDir.multiplyScalar(8)); // è·ç¦»ç›¸æœºæ›´è¿‘ä¸€ç‚¹

            gsap.to(targetPhoto.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                duration: 1, ease: "back.out(1.7)"
            });
            gsap.to(targetPhoto.scale, { x: 2, y: 2, z: 2, duration: 1 });
            gsap.to({}, { duration: 1, onUpdate: () => targetPhoto.lookAt(camera.position) });
        }

        // --- MediaPipe Hands ---
        const videoElement = document.getElementById('video-input');
        const handStatus = document.getElementById('hand-status');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('video-input').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                APP_STATE.isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                analyzeGesture(landmarks);
            } else {
                APP_STATE.isHandDetected = false;
                handStatus.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
        }

        function analyzeGesture(landmarks) {
            const isFingerExtended = (tipId, pipId) => {
                const wrist = landmarks[0];
                const tip = landmarks[tipId];
                const pip = landmarks[pipId];
                const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                return dTip > dPip * 1.2;
            };

            const thumbOpen = isFingerExtended(4, 2);
            const indexOpen = isFingerExtended(8, 6);
            const middleOpen = isFingerExtended(12, 10);
            const ringOpen = isFingerExtended(16, 14);
            const pinkyOpen = isFingerExtended(20, 18);

            const openFingersCount = [thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;

            if (openFingersCount <= 1) {
                handStatus.innerText = "è¯†åˆ«: âœŠ æ¡æ‹³ (èšåˆ)";
                switchState('TREE');
            }
            else if (openFingersCount >= 4) {
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                if (pinchDist < 0.05) {
                    handStatus.innerText = "è¯†åˆ«: ğŸ‘Œ æåˆ (æ”¾å¤§)";
                    switchState('ZOOM');
                } else {
                    handStatus.innerText = "è¯†åˆ«: ğŸ– å¼ å¼€ (æ•£å¼€)";
                    if (APP_STATE.mode !== 'SCATTER') switchState('SCATTER');
                    const handX = (landmarks[0].x - 0.5) * 2; 
                    const handY = (landmarks[0].y - 0.5) * 2;
                    APP_STATE.targetRotation.x = handY * 0.5;
                    APP_STATE.targetRotation.y = handX * 0.5;
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        cameraUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            let needsUpdate = false;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const data = particlesData[i];
                const x = data.currentPos.x;
                const y = data.currentPos.y + Math.sin(time + data.phase) * 0.1;
                const z = data.currentPos.z;

                dummy.position.set(x, y, z);
                dummy.scale.setScalar(data.scale);
                dummy.lookAt(camera.position); 
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            if (APP_STATE.mode === 'SCATTER' || APP_STATE.mode === 'ZOOM') {
                scene.rotation.x += (APP_STATE.targetRotation.x - scene.rotation.x) * 0.05;
                scene.rotation.y += (APP_STATE.targetRotation.y - scene.rotation.y) * 0.05;
            } else {
                scene.rotation.y += 0.002;
                scene.rotation.x += (0 - scene.rotation.x) * 0.05;
            }

            photosGroup.children.forEach((mesh, i) => {
                 mesh.position.y += Math.sin(time * 2 + i) * 0.01;
            });

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
